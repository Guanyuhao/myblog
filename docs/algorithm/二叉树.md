# js äºŒå‰æ ‘

## ç”Ÿæˆä¸€é¢—äºŒå‰æ ‘

- æŠŠç¬¬ä¸€ä½å½“åšæ ¹èŠ‚ç‚¹ï¼Œæ¯”æ ¹èŠ‚ç‚¹å°çš„æ•°æ”¾åœ¨å·¦å­æ ‘ä¸Šï¼Œæ¯”æ ¹èŠ‚ç‚¹å¤§çš„æ•°æ”¾åˆ°å³å­æ ‘ä¸Šï¼Œä»¥æ­¤ç±»æ¨ã€‚
- æŠŠä¸‹é¢æ•°ç»„ç”Ÿæˆä¸€ä¸ªäºŒå‰æ ‘ï¼š`let nodes = [8,3,6,4,9,11,2,5,7]`
- ç»“æ„å¦‚ä¸‹

<img alt="" class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2017/11/2/1bcd257d35ac8b2f9e6be623bd5f7262?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="https://user-gold-cdn.xitu.io/2017/11/2/1bcd257d35ac8b2f9e6be623bd5f7262?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

```js
  let tree = {
      key: 8,
      left: {
          key: 3,
          left: {
              key: 2,
              left: null,
              right: null
          },
          right: {
              key: 6,
              left: {
                  key: 4,
                  left: null,
                  right: {
                      key: 5,
                      left: null,
                      right: null
                  }
              },
              right: {
                  key: 7,
                  left: null,
                  right: null
              }
          }
      }
      right: {
          key: 9,
          left: null,
          right: {
              key: 11,
              left: null,
              right: null
          }
      }
  }
```

> å®ç°ä»£ç 

### `insert` `bulkInsert` `showTree`

- API

  - `insert` æ·»åŠ ä¸€ä¸ªå­æ ‘ï¼Œä¼ å€¼ Number

  ```js
  insert(key) {
    //æ·»åŠ ä¸€ä¸ªæ–°å­æ ‘
    let newNode = this.Node(key);
    let _insertNode = (node, newNode) => {
      //åˆ¤æ–­æ–°äºŒå‰æ ‘çš„å€¼å’ŒåŸæœ‰èŠ‚ç‚¹çš„å€¼
      if (newNode.key < node.key) {
        if (node.left === null) {
          //åˆ¤æ–­å·¦èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
          node.left = newNode;
        } else {
          _insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          //åˆ¤æ–­å³èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
          node.right = newNode;
        } else {
          _insertNode(node.right, newNode);
        }
      }
    };
    if (this.root === null) {
      //å¦‚æœæ²¡æœ‰æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæŠŠä¼ å…¥çš„å€¼å½“æ ¹èŠ‚ç‚¹
      this.root = newNode;
    } else {
      //å¦‚æœæœ‰æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæŠŠä¼ å…¥çš„å€¼æ’åˆ°äºŒå‰æ ‘ä¸Š
      _insertNode(this.root, newNode);
    }
  }
  ```

  - `bulkInsert` æ‰¹é‡æ·»åŠ å­æ ‘ï¼Œä¼ å€¼ Array

  ```js
  bulkInsert(nodes) {
    nodes.forEach(key => {
      //éå†æ•°ç»„ï¼Œæ’å…¥å­æ ‘
      this.insert(key);
    });
  }
  ```

  - `showTree` è¿”å›äºŒå‰æ ‘å¯¹è±¡

  ```js
   showTree() {
    //è¿”å›äºŒå‰æ ‘å¯¹è±¡
    return this.root;
  }
  ```

### éå†

> å…ˆåºéå†ã€ä¸­åºéå†ã€ååºéå†(æ·±åº¦)ï¼Œ å¹¿åº¦éå†

#### å…ˆåºéå† `preOrderTraverse`

- å…ˆåºéå†
  - æ ¹å·¦å³

```js
 preOrderTraverse(fn) {
    //å…ˆåºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
    let preOrderTraverseNode = (node, callback) => {
      if (node !== null) {
        callback(node.key);
        preOrderTraverseNode(node.left, callback);
        preOrderTraverseNode(node.right, callback);
      }
    };
    preOrderTraverseNode(this.root, fn);
  }
```

#### ä¸­åºéå† `inOrderTraverse`

- ä¸­åºéå†
  - å·¦æ ¹å³

```js
preOrderTraverse(fn) {
  //å…ˆåºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
  let preOrderTraverseNode = (node, callback) => {
    if (node !== null) {
      callback(node.key);
      preOrderTraverseNode(node.left, callback);
      preOrderTraverseNode(node.right, callback);
    }
  };
  preOrderTraverseNode(this.root, fn);
}
```

#### ååºéå† `postOrderTraverse`

- ååºéå†
  - å·¦å³æ ¹

```js
postOrderTraverse(fn) {
  //ååºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
  let postOrderTraverseNode = (node, callback) => {
    if (node !== null) {
      postOrderTraverseNode(node.left, callback);
      postOrderTraverseNode(node.right, callback);
      callback(node.key);
    }
  };
  postOrderTraverseNode(this.root, fn);
}
```

#### å¹¿åº¦éå† `breadthTraversal`

- å¹¿åº¦éå†
  - æŒ‰ç…§å±‚æ¬¡ä¸€å±‚å±‚éå†

```js
breadthTraversal(fn) {
  // å¹¿åº¦éå†
  let breadthTraversalNode = (node, callback) => {
    if (node !== null) {
      let que = [node];
      while (que.length !== 0) {
        node = que.shift();
        callback(node.key);
        if (node.left) {
          que.push(node.left);
        }
        if (node.right) {
          que.push(node.right);
        }
      }
    }
  };
  breadthTraversalNode(this.root, fn);
}
```

### `max` `min` `search`

> äºŒå‰æ ‘èŠ‚ç‚¹æŸ¥æ‰¾

- æŸ¥æ‰¾æœ€å¤§å€¼ã€æœ€å°å€¼ `max` `min`

```js
min() {
  let node = this.root;
  if (node) {
    while (node && node.left !== null) {
      node = node.left;
    }
    return node.key;
  }
}

max() {
  let node = this.root;
  if (node) {
    while (node && node.right !== null) {
      node = node.right;
    }
    return node.key;
  }
}
```

- æŸ¥æ‰¾äºŒå‰æ ‘ä¸­èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ `search`

```js
search(key) {
  let searchNode = (node, key) => {
    if (node === null) {
      return false;
    }
    if (key > node.key) {
      return searchNode(node.right, key);
    } else if (key < node.key) {
      return searchNode(node.left, key);
    } else {
      return true;
    }
  };
  return searchNode(this.root, key);
}
```

### `Remove`

> äºŒå‰æ ‘èŠ‚ç‚¹åˆ é™¤

- éœ€è¦åˆ¤æ–­è¿™ä¸ªèŠ‚ç‚¹æ˜¯å¦è¿˜æœ‰å­æ ‘ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼Œæ— å­æ ‘ï¼Œæœ‰å•å­æ ‘ï¼Œæœ‰åŒå­æ ‘ `remove`

```js
remove(key) {
    let findMinNode = (node, key) => {
      node = node || this.root;
      if (node) {
        while (node && node.left !== null) {
          node = node.left;
        }
        return node;
      }
      return null;
    };
    let removeNode = (node, key) => {
      if (node === null) {
        return null;
      }
      if (key < node.key) {
        node.left = removeNode(node.left, key);
        return node;
      } else if (key > node.key) {
        node.right = removeNode(node.right, key);
        return node;
      } else {
        if (node.left === null && node.right === null) {
          node = null;
          return node;
        }
        if (node.left === null) {
          node = node.right;
          return node;
        } else if (node.right === null) {
          node = node.left;
          return node;
        }
        if (node.left !== null && node.right !== null) {
          let aux = findMinNode(node.right);
          node.key = aux;
          node.right = removeNode(node.right, aux.key);
          return node;
        }
      }
    };
    this.root = removeNode(this.root, key);
  }
```

### äºŒå‰æ ‘å¯¹è±¡ `BinaryTree`

```js
class BinaryTree {
  constructor(tree = []) {
    this.root = null; //æ ‘æ ¹
    this.Node = key => {
      //ç”Ÿæˆä¸€ä¸ªæ–°çš„å­æ ‘
      let _obj = Object.create(null, {});
      _obj.key = key;
      _obj.left = null;
      _obj.right = null;
      return _obj;
    };
    //åˆå§‹åŒ–äºŒå‰æ ‘
    if (typeof tree === "number") {
      this.insert(tree);
    } else if (Array.isArray(tree)) {
      this.bulkInsert(tree);
    } else {
      console.error("è¯·è¾“å…¥Numberç±»å‹æˆ–è€…Arrayç±»å‹çš„å‚æ•°");
    }
  }
  insert(key) {
    //æ·»åŠ ä¸€ä¸ªæ–°å­æ ‘
    let newNode = this.Node(key);
    let _insertNode = (node, newNode) => {
      //åˆ¤æ–­æ–°äºŒå‰æ ‘çš„å€¼å’ŒåŸæœ‰èŠ‚ç‚¹çš„å€¼
      if (newNode.key < node.key) {
        if (node.left === null) {
          //åˆ¤æ–­å·¦èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
          node.left = newNode;
        } else {
          _insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          //åˆ¤æ–­å³èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
          node.right = newNode;
        } else {
          _insertNode(node.right, newNode);
        }
      }
    };
    if (this.root === null) {
      //å¦‚æœæ²¡æœ‰æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæŠŠä¼ å…¥çš„å€¼å½“æ ¹èŠ‚ç‚¹
      this.root = newNode;
    } else {
      //å¦‚æœæœ‰æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæŠŠä¼ å…¥çš„å€¼æ’åˆ°äºŒå‰æ ‘ä¸Š
      _insertNode(this.root, newNode);
    }
  }
  bulkInsert(nodes) {
    nodes.forEach(key => {
      //éå†æ•°ç»„ï¼Œæ’å…¥å­æ ‘
      this.insert(key);
    });
  }
  showTree() {
    //è¿”å›äºŒå‰æ ‘å¯¹è±¡
    return this.root;
  }
  inOrderTraverse(fn) {
    //ä¸­åºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
    let inOrderTraverseNode = (node, callback) => {
      if (node !== null) {
        inOrderTraverseNode(node.left, callback);
        callback(node.key);
        inOrderTraverseNode(node.right, callback);
      }
    };
    inOrderTraverseNode(this.root, fn);
  }
  preOrderTraverse(fn) {
    //å…ˆåºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
    let preOrderTraverseNode = (node, callback) => {
      if (node !== null) {
        callback(node.key);
        preOrderTraverseNode(node.left, callback);
        preOrderTraverseNode(node.right, callback);
      }
    };
    preOrderTraverseNode(this.root, fn);
  }
  postOrderTraverse(fn) {
    //ååºéå†ï¼Œä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°
    let postOrderTraverseNode = (node, callback) => {
      if (node !== null) {
        postOrderTraverseNode(node.left, callback);
        postOrderTraverseNode(node.right, callback);
        callback(node.key);
      }
    };
    postOrderTraverseNode(this.root, fn);
  }
  breadthTraversal(fn) {
    // å¹¿åº¦éå†
    let breadthTraversalNode = (node, callback) => {
      if (node !== null) {
        let que = [node];
        while (que.length !== 0) {
          node = que.shift();
          callback(node.key);
          if (node.left) {
            que.push(node.left);
          }
          if (node.right) {
            que.push(node.right);
          }
        }
      }
    };
    breadthTraversalNode(this.root, fn);
  }
  min() {
    let node = this.root;
    if (node) {
      while (node && node.left !== null) {
        node = node.left;
      }
      return node.key;
    }
  }
  max() {
    let node = this.root;
    if (node) {
      while (node && node.right !== null) {
        node = node.right;
      }
      return node.key;
    }
  }
  search(key) {
    let searchNode = (node, key) => {
      if (node === null) {
        return false;
      }
      if (key > node.key) {
        return searchNode(node.right, key);
      } else if (key < node.key) {
        return searchNode(node.left, key);
      } else {
        return true;
      }
    };
    return searchNode(this.root, key);
  }
  remove(key) {
    let findMinNode = (node, key) => {
      node = node || this.root;
      if (node) {
        while (node && node.left !== null) {
          node = node.left;
        }
        return node;
      }
      return null;
    };
    let removeNode = (node, key) => {
      if (node === null) {
        return null;
      }
      if (key < node.key) {
        node.left = removeNode(node.left, key);
        return node;
      } else if (key > node.key) {
        node.right = removeNode(node.right, key);
        return node;
      } else {
        if (node.left === null && node.right === null) {
          node = null;
          return node;
        }
        if (node.left === null) {
          node = node.right;
          return node;
        } else if (node.right === null) {
          node = node.left;
          return node;
        }
        if (node.left !== null && node.right !== null) {
          let aux = findMinNode(node.right);
          node.key = aux;
          node.right = removeNode(node.right, aux.key);
          return node;
        }
      }
    };
    this.root = removeNode(this.root, key);
  }
}

let nodes = [8, 3, 6, 4, 9, 11, 2, 5, 7];
let binaryTree = new BinaryTree(nodes);
let tree = binaryTree.showTree();
let arr1 = [],
  arr2 = [],
  arr3 = [],
  arr4 = [];
binaryTree.inOrderTraverse(key => {
  arr1.push(key); //ä¸­åºéå†[2, 3, 4, 5, 6, 7, 8, 9, 11]
});
binaryTree.preOrderTraverse(key => {
  arr2.push(key); //å…ˆåºéå†[8, 3, 2, 6, 4, 5, 7, 9, 11]
});
binaryTree.postOrderTraverse(key => {
  arr3.push(key); //ååºéå†[2, 5, 4, 7, 6, 3, 11, 9, 8]
});
binaryTree.breadthTraversal(key => {
  arr4.push(key); //ååºéå†[8, 3, 9, 2, 6, 11, 4, 7, 5]
});
console.log(arr1, arr2, arr3, arr4);
console.log(binaryTree.min(), binaryTree.max()); // 2, 11
console.log(binaryTree.search(2), binaryTree.search(1)); // true,false
binaryTree.remove(2);
binaryTree.insert(1);
console.log(binaryTree.search(2), binaryTree.search(1)); // false,true
```

> å¤šå‰æ ‘ ğŸ™‚
